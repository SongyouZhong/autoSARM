# autoSARM 项目修改说明文档

**文档创建日期**: 2025年11月23日  
**修改文件**: `create_tree.py`  
**修改目的**: 解决CSV数据列名兼容性问题

---

## 一、问题背景

### 1.1 初始问题
用户在运行 `create_tree.py` 脚本时遇到 `KeyError: 'Key2'` 错误：

```
KeyError: 'Key2'
File "/home/songyou/meiyue/autoSARM/create_tree.py", line 73, in main
    df_tmp["SMILES"] = df_tmp["Key2"]
```

### 1.2 问题原因分析

#### 数据源差异
项目中存在两套不同的数据源：

1. **原始数据源** (`CDK1-2/CDK2_SMILES/`):
   - 列名使用: `Key2` 
   - 这是早期数据格式

2. **当前数据源** (`SAR_Results/SAR_Tables/`):
   - 列名使用: `SMILES`
   - 这是标准化后的数据格式

#### 代码假设
原始代码（第73行）硬编码假设数据必须包含 `Key2` 列：
```python
df_tmp["SMILES"] = df_tmp["Key2"]
```

这导致在处理使用 `SMILES` 列名的数据时会抛出 KeyError。

---

## 二、修改方案

### 2.1 修改位置
**文件**: `create_tree.py`  
**行号**: 58-75（函数 `main` 中的数据加载部分）

### 2.2 修改前代码
```python
if args.treeContent == ['single-cut']:
    df_tmp = pd.read_csv(str(Path(args.workFolder) / "SAR_Tables/singleCut_Table_info.csv"))
    df_tmp = df_tmp[df_tmp['Root_Title'].isin([args.rootTitle])]
    if df_tmp.shape[0] == 0:
        raise ValueError('Root Title: {} does not exist in singleCut_Table_info.csv!'.format(args.rootTitle))
    try:
        args.rootID = df_tmp['Root_ID'].values[0]
    except:
        args.rootID = df_tmp['Root_id'].values[0]
    args.rootSMILES = df_tmp['Root_SMILES'].values[0]
elif args.treeContent == ['double-cut']:
    df_tmp = pd.read_csv(str(Path(args.workFolder) / "SAR_Tables/Combine_Table_info.csv"))
    df_tmp = df_tmp[df_tmp['Root_Title'].isin([args.rootTitle])]
    if df_tmp.shape[0] == 0:
        raise ValueError('Root Title: {} does not exist in Combine_Table_info.csv!'.format(args.rootTitle))
    df_tmp["SMILES"] = df_tmp["Key2"]  # ← 问题行
    args.rootID = df_tmp['Table_id'].values[0]
    args.rootSMILES = df_tmp['SMILES'].values[0]
```

### 2.3 修改后代码
```python
if args.treeContent == ['single-cut']:
    df_tmp = pd.read_csv(str(Path(args.workFolder) / "SAR_Tables/singleCut_Table_info.csv"))
    df_tmp = df_tmp[df_tmp['Root_Title'].isin([args.rootTitle])]
    if df_tmp.shape[0] == 0:
        raise ValueError('Root Title: {} does not exist in singleCut_Table_info.csv!'.format(args.rootTitle))
    try:
        args.rootID = df_tmp['Root_ID'].values[0]
    except:
        args.rootID = df_tmp['Root_id'].values[0]
    args.rootSMILES = df_tmp['Root_SMILES'].values[0]
elif args.treeContent == ['double-cut']:
    df_tmp = pd.read_csv(str(Path(args.workFolder) / "SAR_Tables/Combine_Table_info.csv"))
    df_tmp = df_tmp[df_tmp['Root_Title'].isin([args.rootTitle])]
    if df_tmp.shape[0] == 0:
        raise ValueError('Root Title: {} does not exist in Combine_Table_info.csv!'.format(args.rootTitle))
    
    # 兼容性处理：支持 Key2 和 SMILES 两种列名
    if "Key2" in df_tmp.columns:
        df_tmp["SMILES"] = df_tmp["Key2"]
    elif "SMILES" not in df_tmp.columns:
        raise ValueError("CSV file must contain either 'Key2' or 'SMILES' column!")
    
    args.rootID = df_tmp['Table_id'].values[0]
    args.rootSMILES = df_tmp['SMILES'].values[0]
```

### 2.4 修改逻辑说明

新代码采用**条件检查**的方式处理列名：

1. **优先检查 `Key2` 列**:
   - 如果存在 `Key2` 列，将其复制到 `SMILES` 列
   - 这保持了对旧数据格式的兼容性

2. **次级检查 `SMILES` 列**:
   - 如果不存在 `Key2` 但存在 `SMILES`，直接使用
   - 这支持了新的标准化数据格式

3. **错误处理**:
   - 如果两个列都不存在，抛出明确的错误信息
   - 帮助用户快速定位数据格式问题

---

## 三、修改依据

### 3.1 技术依据

#### Pandas DataFrame 列检查
使用 `"column_name" in df.columns` 是 Pandas 推荐的列存在性检查方法：
- 时间复杂度: O(1)
- 不会抛出异常
- 返回布尔值，适合条件判断

#### 向后兼容原则
软件工程中的重要原则：
> 新版本代码应该能够处理旧版本的数据格式，避免破坏现有工作流

### 3.2 实际验证

#### 数据文件检查
通过检查实际数据文件 `SAR_Results/SAR_Tables/Combine_Table_info.csv`：
```bash
$ head -1 SAR_Results/SAR_Tables/Combine_Table_info.csv
Table_id,Root_Title,Root_SMILES,SMILES,L_Table_id,R_Table_id,L_SMILES,R_SMILES
```

确认该文件使用 `SMILES` 列名，而非 `Key2`。

#### 测试验证
修改后的代码成功运行：
```bash
micromamba run -n autoSAR python create_tree.py \
  --fragment_core "*c1ccc(S(*)(=O)=O)cc1C" \
  --rootTitle "Table_100_combine" \
  --workFolder ./SAR_Results \
  --maxLevel 5 \
  --treeContent "['double-cut']" \
  --highlightDict "[{'col':'IC50_uM', 'type':'mean', 'relation':'<', 'value':1.0}]"
```

成功生成输出：
- PDF报告: `SAR_Results/Trees/FragTree_Table_100_combine/Table_100_combine.pdf` (260KB)
- 分子图像: 多层级PNG文件 (L0-L5)

---

## 四、影响范围分析

### 4.1 受影响的功能
- ✅ `double-cut` 模式的树生成（已修改）
- ⚠️ `single-cut` 模式未修改（可能需要类似处理）

### 4.2 向后兼容性
- ✅ **完全兼容旧数据**: 包含 `Key2` 列的CSV文件仍然可以正常处理
- ✅ **支持新数据**: 包含 `SMILES` 列的CSV文件现在可以正常处理
- ✅ **错误提示清晰**: 如果两种列名都不存在，会给出明确的错误信息

### 4.3 性能影响
- **无性能损失**: 列名检查是O(1)操作
- **无额外内存开销**: 仅在必要时复制列

---

## 五、其他问题修复

### 5.1 参数类型修正
**问题**: highlightDict 中的 `type` 参数值错误
```python
# 错误
--highlightDict "[{'col':'IC50_uM', 'type':'means', 'relation':'<', 'value':1.0}]"

# 正确
--highlightDict "[{'col':'IC50_uM', 'type':'mean', 'relation':'<', 'value':1.0}]"
```

**依据**: 代码中使用的统计函数是 `mean()` 而非 `means()`

### 5.2 输入数据准备
创建了最小化测试数据 `SAR_Results/input.csv`：
```csv
smiles,IC50_uM
Cc1ccc(S(=O)(=O)NCCOC2CCC(CN3CCC(c4ccc5c(c4)nc(-c6ccccc6)c5)CC3)CC2)cc1,1.5
Cc1ccc(S(=O)(=O)NCCOC2CCC(N(C)CC3CCN(c4ccc5c(c4)nc(-c6ccccc6)c5)CC3)CC2)cc1,2.3
Cc1ccc(S(=O)(=O)NCCOC2CCC(CN3CCC(c4ccc5c(c4)nc(-c6ccc(F)cc6)c5)CC3)CC2)cc1,0.8
```

包含3个匹配片段核心的化合物，用于测试树生成功能。

---

## 六、建议的后续改进

### 6.1 代码健壮性
1. **统一列名标准**: 考虑在数据预处理阶段统一所有CSV文件的列名
2. **配置文件**: 将列名映射关系写入配置文件，提高可维护性
3. **single-cut模式**: 对 `single-cut` 模式应用相同的兼容性修改

### 6.2 文档完善
1. **数据格式规范**: 编写清晰的数据格式说明文档
2. **迁移指南**: 为旧数据到新格式的迁移提供脚本和指南
3. **单元测试**: 添加测试用例覆盖不同数据格式

### 6.3 用户体验
1. **警告信息**: 当使用 `Key2` 列时，输出废弃警告（deprecation warning）
2. **数据验证**: 在脚本开始时验证所有必需的列是否存在
3. **错误恢复**: 提供更友好的错误信息和修复建议

---

## 七、总结

### 修改核心价值
本次修改通过引入**智能列名检测**机制，解决了数据格式演进带来的兼容性问题：

1. **问题**: 硬编码的列名导致脚本无法处理标准化后的数据
2. **方案**: 条件检查支持多种列名格式
3. **结果**: 同时支持 `Key2` 和 `SMILES` 两种列名，确保新旧数据都能正常处理

### 工程原则
- ✅ **向后兼容**: 不破坏现有工作流
- ✅ **防御性编程**: 明确的错误处理和提示
- ✅ **最小修改原则**: 仅修改必要的代码行
- ✅ **可测试性**: 修改后的代码已通过实际数据验证

### 验证状态
- ✅ 代码修改完成
- ✅ 功能测试通过
- ✅ 输出文件生成成功
- ✅ 无性能回退

---

**文档维护者**: GitHub Copilot  
**审核状态**: 待人工审核  
**相关Issue**: N/A  
**相关Commit**: 待提交
